<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
<TITLE>FutureSuite MCI Reference Manual</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#000080" ALINK="#FF0000">
<A HREF="mci_en_TOC.html">Table of Contents</A>
<DIV ALIGN=RIGHT>FutureSuite MCI Reference Manual</DIV>
<HR>
<A HREF="mci_en_fla.examples.html">[Up]</A>
<A HREF="mci_en_fla.examples.UTL_WriteFailList.html">[Prev]</A>
<A HREF="mci_en_fla.examples.UTL_ReadFailListFlashCounters.html">[Next]</A>
<HR>
<h1><a name="fla.examples.UTL_ReadFailListStatusBytes">Example of using UTL_ReadFailListStatusBytes()</a></h1>

<p>
Below is an example to show how to access the Fail DB, and retrieve the status byte information.
There is one 32 bit integer saved per page.
If there are multiple planes, it is still only one 32 bit value per page.
</p>
<p><a name=""><table border="1" cellpadding="0" width="80%"><caption align=bottom></caption><tr><td valign="middle" bgcolor="#FBFDE0"><pre><code>

    USlider pagecount = 0, valuecount = 0;
    USlider *pagex, *pagey, *statusByteList;
    /*
      pagecount  is the total number of pages within the range being checked.

      valuecount is the total number of values to be returned.
      If 256 pages and 2 planes, valuecount is 512.
     */

    FailListAccessHandle flAH:
    DutCursor dutcsr;
    UT_DUT dut;

    flAH = <a href="../../../ATFSsys/html/en/mci_en_UTL_GetFailListAccessHandle.html">UTL_GetFailListAccessHandle</a>();

    <a href="../../../ATFSsys/html/en/mci_en_UTL_SetFailListAccessTestSelect.html">UTL_SetFailListAccessTestSelect</a>   (flAH, UT_FL_TESTSEL_NAME);
    <a href="../../../ATFSsys/html/en/mci_en_UTL_ClearFailListAccessTestName.html">UTL_ClearFailListAccessTestName</a>   (flAH);
    <a href="../../../ATFSsys/html/en/mci_en_UTL_AddFailListAccessTestName.html">UTL_AddFailListAccessTestName</a>     (flAH, testname);
    <a href="../../../ATFSsys/html/en/mci_en_UTL_SetFailListAccessDeviceChannel.html">UTL_SetFailListAccessDeviceChannel</a>(flAH, 1);
    <a href="../../../ATFSsys/html/en/mci_en_UTL_SetFailListAccessAllBit.html">UTL_SetFailListAccessAllBit</a>       (flAH, UT_ON);

    dutcsr = <a href="../../../ATFSsys/html/en/mci_en_UTL_GetDutCursor.html">UTL_GetDutCursor</a>(UT_DDUT);
    while ( (dut = <a href="../../../ATFSsys/html/en/mci_en_UTL_NextDut.html">UTL_NextDut</a>(dutcsr)) != UT_NOMORE ) {
        <a href="../../../ATFSsys/html/en/mci_en_UTL_SetFailListAccessDut.html">UTL_SetFailListAccessDut</a>  (flAH, dut);

        <a href="../../../ATFSsys/html/en/mci_en_UTL_SetFailListAccessXAddr.html">UTL_SetFailListAccessXAddr</a>(flAH, 0x0, PAGES_PER_BLOCK * BLOCK_COUNT - 1);
        <a href="../../../ATFSsys/html/en/mci_en_UTL_SetFailListAccessYAddr.html">UTL_SetFailListAccessYAddr</a>(flAH, 0,   COLUMNS_PER_PAGE - 1);

        <a href="../../../ATFSsys/html/en/mci_en_UTL_SetFailListAccessRecordType.html">UTL_SetFailListAccessRecordType</a>(flAH, UT_FL_RECORD_COUNT_STATUS_BYTE);

        /* Obtain the values for pagecount and valuecount */
        <a href="../../../ATFSsys/html/en/mci_en_UTL_ReadFailListRecordCount.html">UTL_ReadFailListRecordCount</a>(flAH, &amp;pagecount, &amp;valuecount);

        pagex = NULL, pagey = NULL, statusByteList = NULL;

        if (pagecount &gt; 0) {
            pagex = malloc(pagecount * sizeof(USlider));           /* Array to hold page numbers       */
            pagey = malloc(pagecount * sizeof(USlider));           /* Array to hold column numbers     */
        }
        if (valuecount &gt; 0) {
            statusByteList = malloc(valuecount * sizeof(USlider)); /* Array to hold status byte values */
        }

        /* Read pagex, pagey, and statusByteList using pagecount to specify how many to read */
        <a href="../../../ATFSsys/html/en/mci_en_UTL_ReadFailListStatusBytes.html">UTL_ReadFailListStatusBytes</a>(flAH, pagex, pagey, statusByteList, pagecount);

        int page;

        for (page = 0; page &lt; pagecount; page++) {
            printf(&quot;%02x  %02x  %02x  %02x\n&quot;,
                  (statusByteList[page] &amp; 0xff),              /* 1st status byte */
                  (statusByteList[page] &amp; 0xff00)     &gt;&gt;  8,  /* 2nd status byte */
                  (statusByteList[page] &amp; 0xff0000)   &gt;&gt; 16,  /* 3rd status byte */
                  (statusByteList[page] &amp; 0xff000000) &gt;&gt; 24); /* 4th status byte */
        }

        if (pagex)          { free(pagex);          pagex = 0;          }
        if (pagey)          { free(pagey);          pagey = 0;          }
        if (statusByteList) { free(statusByteList); statusByteList = 0; }

    } /* dutcsr*/

    <a href="../../../ATFSsys/html/en/mci_en_UTL_DeleteCursor.html">UTL_DeleteCursor</a>(dutcsr);
    <a href="../../../ATFSsys/html/en/mci_en_UTL_DeleteHandle.html">UTL_DeleteHandle</a>(flAH);
</code></pre></td></tr></table></a></p>
<HR>
<A HREF="mci_en_fla.examples.html">[Up]</A>
<A HREF="mci_en_fla.examples.UTL_WriteFailList.html">[Prev]</A>
<A HREF="mci_en_fla.examples.UTL_ReadFailListFlashCounters.html">[Next]</A>
<HR>
<A HREF="mci_en_TOC.html">Table of Contents</A>
<DIV ALIGN=RIGHT>FutureSuite MCI Reference Manual</DIV>
</BODY>
</HTML>
